
import java.net.Socket;
import java.io.*;

import SuperDog.Dog;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.net.ServerSocket;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.Signature;
import java.util.Map;

import java.security.MessageDigest;

/**
 * Purpose: To integrate new key with the old security module. Module: Security.
 *
 * <p>
 * Comments: 1. If stuck on "curDog.login(vendorCode)" , turn off McAfee's
 * "IPS Host" protection module. Since Superdog's login function may be blocked
 * in 32-bit JDK.
 * <p>
 * JDK version used: JDK1.6 - 32 bit
 */
public class DogStatusManager {
	// Dog curDog = new Dog(Dog.DOG_DEFAULT_FID);// mode 0
	Dog curDog = new Dog(1);
	private static DogStatusManager dogStatusManager;
	private boolean status;
	private boolean dogStatus;

	public static final String SIGNATURE_ALGORITHM = "SHA256withRSA";
	public static final String ENCODE_ALGORITHM = "SHA-256";
	public static final String PLAIN_TEXT = "test string";

	public static final String vendorCode = new String(
			"FORGITHUB");

	static {
		dogStatusManager = new DogStatusManager();
		System.loadLibrary("DogJava_x64");
	}

	public static DogStatusManager getInstance() {
		return dogStatusManager;
	}

	public synchronized void setStatus(boolean status) {
		this.status = status;
	}

	public synchronized boolean getStatus() {
		return status;
	}

	public synchronized void setDogStatus(boolean status) {
		this.dogStatus = status;
	}

	public synchronized boolean getDogStatus() {
		return dogStatus;
	}

	public synchronized int updateDogStatus() {
		/*******************************************************************
		 * Turn off McAfee's "IPS Host" protection if curDog.login is blocked by
		 * in 32-bit JDK. statusNum: success code 0 VendorCode is generated by
		 * software Path: C:\Program Files
		 * (x86)\Gemalto\SuperDog\2.4\VendorCodes\YZYUE.hvc
		 */
		curDog.login(vendorCode);
		int statusNum = curDog.getLastError();
		return statusNum;
	}

	/**
	 * Signature
	 *
	 * @param privateKey
	 *            Private Key
	 * @param plain_text
	 *            TEXT to send
	 * @return
	 */
	public static byte[] sign(PrivateKey privateKey, String plain_text) {
		MessageDigest messageDigest;
		byte[] signed = null;
		try {
			messageDigest = MessageDigest.getInstance(ENCODE_ALGORITHM);
			messageDigest.update(plain_text.getBytes());
			byte[] outputDigest_sign = messageDigest.digest();
			System.out.println("SHA-256 Encrypted-----》"
					+ bytesToHexString(outputDigest_sign));
			Signature Sign = Signature.getInstance(SIGNATURE_ALGORITHM);
			Sign.initSign(privateKey);
			Sign.update(outputDigest_sign);
			signed = Sign.sign();
			System.out.println("SHA256withRSA Signed-----》"
					+ bytesToHexString(signed));
		} catch (Exception e) {
			e.printStackTrace();
		}
		return signed;
	}

	/**
	 * bytes[]to Hex String
	 *
	 * @param src
	 * @return
	 */
	public static String bytesToHexString(byte[] src) {
		StringBuilder stringBuilder = new StringBuilder("");
		if (src == null || src.length <= 0) {
			return null;
		}
		for (int i = 0; i < src.length; i++) {
			int v = src[i] & 0xFF;
			String hv = Integer.toHexString(v);
			if (hv.length() < 2) {
				stringBuilder.append(0);
			}
			stringBuilder.append(hv);
		}
		return stringBuilder.toString();
	}

	private static void invoke(final Socket socket) throws Exception {
		// new Thread(new Runnable() {
		// public void run() {
		try {
			int StatID = DogStatusManager.getInstance().updateDogStatus();
			boolean newStat = (StatID == 0);
			DogStatusManager.getInstance().setDogStatus(newStat);
			String msg = "false";
			if (newStat) {
				msg = "true";
			}
			// Generate Key pair
			Map<String, byte[]> keyMap = RSA.generateKeyBytes();
			PublicKey publicKey = RSA.restorePublicKey(keyMap
					.get(RSA.PUBLIC_KEY));
			PrivateKey privateKey = RSA.restorePrivateKey(keyMap
					.get(RSA.PRIVATE_KEY));
			// Sign
			byte[] sing_msg = sign(privateKey, msg);
			/*********************************************
			 * DataOutputStream dOut = new
			 * DataOutputStream(signSocket.getOutputStream());
			 * dOut.writeInt(sing_msg.length); // write length of the message
			 * dOut.write(sing_msg); // write the message
			 */
			// Send Key
			OutputStream out = socket.getOutputStream();
			ObjectOutputStream objOut = new ObjectOutputStream(out);
			// Send my name
			objOut.writeObject(new String(msg));
			// Send my key
			objOut.writeObject(publicKey);
			objOut.writeObject(sing_msg);
			// Send Original Msg
			// OutputStream os=socket.getOutputStream();
			// PrintWriter pw=new PrintWriter(os);
			// pw.write(sing_byte);
			System.out.println("DOG@" + msg);
			// dOut.flush();
			// dOut.close();
			// objOut.flush();
			// objOut.close();
		} catch (IOException e) {
			System.out.println("Holy@" + e);
		} finally {
			try {
				// socket.close();
				// signSocket.close();
			} catch (Exception ex) {
				System.out.println("HolySocket@" + ex);
			}
		}
		// }
		// }).start();
	}

	public static void main(String[] args) throws Exception {
		ServerSocket server = new ServerSocket(6345);
		// ServerSocket SignServer = new ServerSocket(8111);
		while (true) {
			Socket socket = server.accept();
			// Socket SignSocket = SignServer.accept();
			invoke(socket);
		}
	}

}
